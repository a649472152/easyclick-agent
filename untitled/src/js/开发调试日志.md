# UI 与后台脚本交互开发调试日志

本文档详细记录了一次将原生脚本改造为UI交互模式的完整开发和调试过程，旨在为后续的维护和开发提供参考，避免重蹈覆辙。

## 1. 初始问题：UI保存配置失败

项目最初的目标是为一套后台监控脚本（`main.js`）增加一个H5配置界面（`index.html`）。

- **现象**: 在手机上点击UI的"保存配置"按钮后，IDE日志显示"保存失败"，后台脚本并未执行相应的保存逻辑。
- **初步诊断**: UI通过 `window.ec.call()` 调用了一个名为 `saveConfigToFile` 的函数，但此函数在 `main.js` 中并未定义。

## 2. 探索阶段：错误的解决方案与连锁反应

为了解决问题，我们进行了一系列尝试，但这些尝试最终都因对EasyClick框架的理解不够深入而被证明是错误的。

### 尝试 1：直接添加函数并用 `ui.register` 注册

- **操作**: 在 `main.js` 中添加了 `saveConfigToFile` 函数，并尝试用 `ui.register()` 将其暴露给UI。
- **结果**: 失败。日志显示 `ui.register` 并不是一个有效的函数。

### 尝试 2：改用 `window.ec.addJSCallback` 注册

- **操作**: 将注册方式修改为 `window.ec.addJSCallback`。
- **结果**: 失败。日志显示 `window` 对象在后台脚本中未定义，证明此API仅适用于UI端，无法在后台脚本（`main.js`）中使用。

### 尝试 3：移除了 `main.js` 的主循环

- **核心洞察**: 我们最终意识到，问题的根源在于 `main.js` 中的 `while(true)` 循环。这个循环 **阻塞了主线程**，导致UI发送过来的所有异步调用请求都被挂起或直接丢弃，永远无法得到执行。
- **操作**: 为了验证这个猜想，我们暂时移除了 `main.js` 的主循环。
- **结果**: 通信成功了，但脚本在执行完一次后就立刻退出了，无法实现持续监控。

### 尝试 4：引入Worker线程模型（错误的架构）

为了解决"主线程阻塞"和"脚本持续运行"的矛盾，我们引入了一个复杂的架构：
- 创建一个 `ui.js` 作为主入口，由它来加载 `index.html`。
- `ui.js` 创建一个后台Worker线程 (`thread.newThread`)。
- 在Worker线程中去执行 `main.js` 的全部内容（包括那个 `while` 循环）。
- UI与Worker之间通过 `worker.execAsyncStr()` 来传递字符串命令，模拟函数调用。

**这个方案导致了一系列新的、更复杂的问题**:
1.  **`postMessage` API误用**: 最初错误地使用了浏览器标准的 `postMessage` API，而EasyClick的Worker并不支持。
2.  **主脚本退出导致Worker销毁**: `ui.js` 在执行完自己的代码后会立刻退出，而主脚本的退出会导致它创建的所有子线程（Worker）被系统强制终止。我们在 `ui.js` 末尾添加 `while(true)` 才解决了这个问题。
3.  **通信极其繁琐**: 所有调用都需要手动拼装成字符串，并且难以传递复杂的数据和返回值。

> **核心教训**: 当一个解决方案变得异常复杂和笨拙时，通常意味着我们走在了一条错误的道路上。应该停下来，重新审视框架本身是否提供了更优雅的解决方案。

## 3. 转折点：回归官方文档

在屡次失败后，我们暂停了探索，回归并仔细阅读了 `EasyClick_iOS脱机版_官方文档.md`。

文档的 **5.10.0版本更新日志** 和 **"UI、脚本与H5互通交互 (高级)"** 章节给了我们决定性的启示：EasyClick官方提供了一套专门为解决此类问题而设计的、成熟的通信机制。

## 4. 正确的架构：官方推荐的UI-脚本通信模型

我们废弃了之前所有的复杂方案，完全基于官方文档对项目进行了重构。

**最终的、正确的架构如下:**

1.  **`src/layout/ui.js` (通信桥梁)**:
    - 作为脚本的 **唯一入口** 运行。
    - 它负责加载UI布局: `ui.layout("main", "index.html");`
    - 它作为"中间件"，为H5和后台脚本"传话"。
    - **H5 -> 后台**: 使用 `ui.registeH5Function("saveConfigToFile", ...)` 注册一个函数给H5调用。当H5调用时，这个函数内部再通过 `ui.callScriptRegisteFunction("scriptHandleSave", ...)` 将请求 **转发** 给后台的`main.js`。
    - **后台 -> H5**: 使用 `ui.registeFunctionToScript("uiTriggerFormReset", ...)` 注册一个函数，让后台可以随时调用它，并通过 `ui.quickCallJs(...)` 来执行H5页面里的JS代码，实现UI刷新。

2.  **`src/js/main.js` (后台核心逻辑)**:
    - **不再是入口文件**，它被设计为一个"模块"，等待UI启动。
    - 使用 `registeScriptFunctionToUI("scriptHandleSave", ...)` 注册一个函数，用来接收并处理来自 `ui.js` 的请求。
    - **可以安全地包含 `while(true)` 主循环**，因为EasyClick框架确保了 `ui.js` 和 `main.js` 运行在不同的上下文中，互相不会阻塞。

## 5. 后续修复与润色

在切换到正确架构后，我们还解决了一些在重构过程中引入的小问题：
- **`ReferenceError`**: 由于代码清理得过于彻底，误删了 `AntiDetectionSystem` 类和 `scanAndProcessOrders` 函数的定义。通过分析项目上下文，我们重新实现了它们。
- **`TypeError`**: `file.write` 和 `file.read` 是错误的API名称。通过查阅 `ios-jslibs/file.js` 官方库，我们将其修正为正确的 `file.writeFile` 和 `file.readFile`。
- **配置项缺失**: 修复了 `config.js` 中缺失 `SECURITY_LEVEL` 导致的日志输出 `undefined` 的问题。

## 最终结论

解决UI与后台脚本通信问题的 **唯一正确途径**，是使用EasyClick官方提供的标准API。任何绕过官方API、试图手动实现线程管理和通信的方案，都将导致不必要的复杂性和稳定性问题。正确的架构清晰、简单且健壮。 